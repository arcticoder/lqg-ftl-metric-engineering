<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimized FTL Ship Deck Plans Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #hull-canvas {
            display: block;
            background: linear-gradient(to bottom, #000011, #000033);
        }
        
        #control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 350px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 12px;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .control-group span {
            color: #4ECDC4;
            font-weight: bold;
        }
        
        .control-group button {
            width: 100%;
            padding: 8px;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 5px;
        }
        
        .control-group button:hover {
            background: #555;
        }
        
        .control-group button.active {
            background: #4ECDC4;
            color: #000;
        }
        
        #deck-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            max-height: 80vh;
            overflow-y: auto;
            width: 280px;
        }
        
        .deck-button {
            display: block;
            width: 100%;
            margin-bottom: 3px;
            padding: 6px;
            background: #222;
            border: 1px solid #444;
            color: #aaa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            text-align: left;
        }
        
        .deck-button:hover {
            background: #333;
            color: #fff;
        }
        
        .deck-button.active {
            background: #4ECDC4;
            color: #000;
        }
        
        #info-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            max-width: 400px;
            font-size: 12px;
        }
        
        .info-item {
            margin-bottom: 5px;
        }
        
        .info-label {
            color: #888;
        }
        
        .info-value {
            color: #4ECDC4;
            font-weight: bold;
        }
        
        #room-info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #4ECDC4;
            border-radius: 8px;
            padding: 20px;
            display: none;
            max-width: 400px;
            z-index: 1000;
        }
        
        #room-info h3 {
            margin-top: 0;
            color: #4ECDC4;
        }
        
        #room-info .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
        }
        
        .room-detail {
            margin-bottom: 8px;
        }
        
        .amenity-list {
            background: #111;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
        }
        
        .amenity-tag {
            display: inline-block;
            background: #333;
            color: #4ECDC4;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin: 2px;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="hull-canvas" width="1200" height="800"></canvas>
        
        <div id="deck-controls">
            <h3 style="margin-top: 0; color: #4ECDC4; font-size: 14px;">Deck Plans (99 crew)</h3>
            <div id="deck-buttons"></div>
        </div>
        
        <div id="control-panel">
            <h3 style="margin-top: 0; color: #4ECDC4;">View Controls</h3>
            
            <div class="control-group">
                <label>View Mode:</label>
                <button id="view-side" class="active" onclick="setViewMode('side')">Side View</button>
                <button id="view-top" onclick="setViewMode('top')">Top View</button>
                <button id="view-3d" onclick="setViewMode('3d')">3D View</button>
            </div>
            
            <div class="control-group">
                <label for="zoom">Zoom Level:</label>
                <input type="range" id="zoom" min="0.1" max="3.0" value="1.0" step="0.1" oninput="updateZoom(this.value)">
                <span id="zoom_value">1.0x</span>
            </div>
            
            <div class="control-group">
                <label for="rotation">Rotation (degrees):</label>
                <input type="range" id="rotation" min="0" max="360" value="0" step="5" oninput="updateRotation(this.value)">
                <span id="rotation_value">0°</span>
            </div>
            
            <div class="control-group">
                <label>Display Options:</label>
                <button id="show-rooms" class="active" onclick="toggleRooms()">Show Rooms</button>
                <button id="show-labels" onclick="toggleLabels()">Show Labels</button>
                <button id="show-hull" class="active" onclick="toggleHull()">Show Hull</button>
            </div>
            
            <div class="control-group">
                <label>Room Types:</label>
                <button id="filter-diplomatic" class="active" onclick="toggleRoomType('diplomatic')">Diplomatic</button>
                <button id="filter-crew" class="active" onclick="toggleRoomType('crew')">Crew</button>
                <button id="filter-systems" class="active" onclick="toggleRoomType('systems')">Systems</button>
                <button id="filter-common" class="active" onclick="toggleRoomType('common')">Common</button>
            </div>
            
            <h4 style="color: #4ECDC4; margin-bottom: 10px;">Optimization Results</h4>
            <div style="font-size: 11px;">
                <div class="info-item"><span class="info-label">ROI:</span> <span class="info-value">249.05%</span></div>
                <div class="info-item"><span class="info-label">Net Profit:</span> <span class="info-value">$512.59M</span></div>
                <div class="info-item"><span class="info-label">Mission Type:</span> <span class="info-value">Diplomatic</span></div>
                <div class="info-item"><span class="info-label">Total Crew:</span> <span class="info-value">99 people</span></div>
                <div class="info-item"><span class="info-label">Operational:</span> <span class="info-value">36 crew</span></div>
                <div class="info-item"><span class="info-label">Diplomatic:</span> <span class="info-value">63 passengers</span></div>
            </div>
        </div>
        
        <div id="info-panel">
            <div id="current-deck-info">
                <div class="info-item"><span class="info-label">Current Deck:</span> <span class="info-value" id="deck-name">Hull Only</span></div>
                <div class="info-item"><span class="info-label">Level:</span> <span class="info-value" id="deck-level">-</span></div>
                <div class="info-item"><span class="info-label">Function:</span> <span class="info-value" id="deck-function">-</span></div>
                <div class="info-item"><span class="info-label">Occupancy:</span> <span class="info-value" id="deck-occupancy">-</span></div>
                <div class="info-item"><span class="info-label">Rooms:</span> <span class="info-value" id="deck-rooms">-</span></div>
            </div>
        </div>
        
        <div id="room-info">
            <button class="close-btn" onclick="closeRoomInfo()">×</button>
            <h3 id="room-name">Room Details</h3>
            <div class="room-detail"><strong>Type:</strong> <span id="room-type">-</span></div>
            <div class="room-detail"><strong>Area:</strong> <span id="room-area">-</span> m²</div>
            <div class="room-detail"><strong>Occupancy:</strong> <span id="room-occupancy">-</span> people</div>
            <div class="room-detail"><strong>Privacy Level:</strong> <span id="room-privacy">-</span></div>
            <div class="amenity-list">
                <strong>Amenities:</strong>
                <div id="room-amenities"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let canvas, gl, program;
        let deckPlansData = null;
        let currentDeck = -1;
        let viewMode = 'side';
        let zoomLevel = 1.0;
        let rotationAngle = 0;
        let showRooms = true;
        let showLabels = false;
        let showHull = true;
        let roomFilters = {
            diplomatic: true,
            crew: true,
            systems: true,
            common: true
        };
        
        // Mouse interaction
        let mouseX = 0, mouseY = 0;
        let isDragging = false;
        let lastMouseX = 0, lastMouseY = 0;
        let cameraX = 0, cameraY = 0;
        
        // Room colors by type
        const roomColors = {
            'vip_quarters': [1.0, 0.8, 0.2, 0.8],      // Gold
            'diplomatic_quarters': [0.2, 0.8, 1.0, 0.8], // Light blue
            'crew_quarters': [0.4, 0.8, 0.4, 0.8],     // Green
            'senior_quarters': [0.8, 0.6, 1.0, 0.8],   // Purple
            'bridge': [1.0, 0.2, 0.2, 0.8],            // Red
            'office': [0.8, 0.8, 0.8, 0.8],            // White
            'lounge': [1.0, 0.6, 0.8, 0.8],            // Pink
            'meeting': [0.6, 0.6, 1.0, 0.8],           // Blue
            'conference': [0.8, 0.4, 0.6, 0.8],        // Maroon
            'dining': [1.0, 0.8, 0.4, 0.8],            // Orange
            'recreation': [0.6, 1.0, 0.6, 0.8],        // Light green
            'exercise': [1.0, 0.4, 0.4, 0.8],          // Red
            'medical': [0.2, 1.0, 0.8, 0.8],           // Cyan
            'operations': [0.8, 0.8, 0.2, 0.8],        // Yellow
            'control': [1.0, 0.2, 0.8, 0.8],           // Magenta
            'workshop': [0.6, 0.4, 0.2, 0.8],          // Brown
            'training': [0.4, 0.6, 0.8, 0.8],          // Steel blue
            'engine': [1.0, 0.0, 0.0, 0.8],            // Bright red
            'processing': [0.0, 0.8, 0.8, 0.8],        // Teal
            'storage': [0.5, 0.5, 0.5, 0.8],           // Gray
            'cargo': [0.3, 0.3, 0.3, 0.8],             // Dark gray
            'common': [0.7, 0.7, 0.9, 0.8]             // Light purple
        };

        // Initialize WebGL
        function initWebGL() {
            canvas = document.getElementById('hull-canvas');
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) {
                alert('WebGL not supported');
                return false;
            }

            // Vertex shader
            const vertexShaderSource = `
                attribute vec2 a_position;
                attribute vec4 a_color;
                uniform vec2 u_resolution;
                uniform vec2 u_translation;
                uniform float u_rotation;
                uniform float u_scale;
                varying vec4 v_color;
                
                void main() {
                    // Apply transformations
                    vec2 position = a_position;
                    
                    // Scale
                    position *= u_scale;
                    
                    // Rotate
                    float c = cos(u_rotation);
                    float s = sin(u_rotation);
                    position = vec2(
                        position.x * c - position.y * s,
                        position.x * s + position.y * c
                    );
                    
                    // Translate
                    position += u_translation;
                    
                    // Convert to clip space
                    vec2 clipSpace = ((position / u_resolution) * 2.0) - 1.0;
                    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
                    v_color = a_color;
                }
            `;

            // Fragment shader
            const fragmentShaderSource = `
                precision mediump float;
                varying vec4 v_color;
                
                void main() {
                    gl_FragColor = v_color;
                }
            `;

            // Create shaders
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            
            // Create program
            program = createProgram(gl, vertexShader, fragmentShader);
            
            // Get attribute and uniform locations
            program.positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
            program.colorAttributeLocation = gl.getAttribLocation(program, 'a_color');
            program.resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');
            program.translationUniformLocation = gl.getUniformLocation(program, 'u_translation');
            program.rotationUniformLocation = gl.getUniformLocation(program, 'u_rotation');
            program.scaleUniformLocation = gl.getUniformLocation(program, 'u_scale');

            // Set up mouse events
            setupMouseEvents();
            
            return true;
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            
            return program;
        }

        function setupMouseEvents() {
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            canvas.addEventListener('mousemove', (e) => {
                mouseX = e.clientX - canvas.offsetLeft;
                mouseY = e.clientY - canvas.offsetTop;
                
                if (isDragging) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    
                    cameraX += deltaX;
                    cameraY += deltaY;
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    
                    render();
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                if (!isDragging) {
                    // Click to select room
                    checkRoomClick(mouseX, mouseY);
                }
                isDragging = false;
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                zoomLevel *= delta;
                zoomLevel = Math.max(0.1, Math.min(5.0, zoomLevel));
                document.getElementById('zoom').value = zoomLevel;
                document.getElementById('zoom_value').textContent = zoomLevel.toFixed(1) + 'x';
                render();
            });
        }

        function checkRoomClick(x, y) {
            if (currentDeck === -1 || !deckPlansData) return;
            
            const deck = deckPlansData.deck_plans[currentDeck];
            if (!deck || !deck.rooms) return;
            
            // Convert screen coordinates to world coordinates
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const worldX = (x - centerX - cameraX) / zoomLevel;
            const worldY = (y - centerY - cameraY) / zoomLevel;
            
            // Check each room
            for (const room of deck.rooms) {
                if (isPointInRoom(worldX, worldY, room)) {
                    showRoomInfo(room);
                    break;
                }
            }
        }

        function isPointInRoom(x, y, room) {
            const boundary = room.boundary;
            if (!boundary || boundary.length < 3) return false;
            
            // Scale coordinates based on view mode
            const scale = viewMode === 'top' ? 3 : 2;
            const roomX = room.center[0] * scale;
            const roomY = viewMode === 'top' ? room.center[1] * scale : 0;
            
            let inside = false;
            for (let i = 0, j = boundary.length - 1; i < boundary.length; j = i++) {
                const xi = boundary[i][0] * scale + roomX;
                const yi = viewMode === 'top' ? boundary[i][1] * scale + roomY : 0;
                const xj = boundary[j][0] * scale + roomX;
                const yj = viewMode === 'top' ? boundary[j][1] * scale + roomY : 0;
                
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            
            return inside;
        }

        function showRoomInfo(room) {
            document.getElementById('room-name').textContent = room.name;
            document.getElementById('room-type').textContent = room.type.replace('_', ' ');
            document.getElementById('room-area').textContent = room.area.toFixed(1);
            document.getElementById('room-occupancy').textContent = room.occupancy;
            document.getElementById('room-privacy').textContent = room.privacy_level;
            
            const amenitiesDiv = document.getElementById('room-amenities');
            amenitiesDiv.innerHTML = '';
            if (room.amenities && room.amenities.length > 0) {
                room.amenities.forEach(amenity => {
                    const tag = document.createElement('span');
                    tag.className = 'amenity-tag';
                    tag.textContent = amenity.replace('_', ' ');
                    amenitiesDiv.appendChild(tag);
                });
            } else {
                amenitiesDiv.textContent = 'None';
            }
            
            document.getElementById('room-info').style.display = 'block';
        }

        function closeRoomInfo() {
            document.getElementById('room-info').style.display = 'none';
        }

        // Embedded deck plans data (avoids CORS issues)
        function loadDeckPlans() {
            deckPlansData = {
  "metadata": {
    "framework": "Ship Hull Geometry Framework",
    "version": "2.0.0 - Optimization-Based",
    "generation_date": "2025-07-13",
    "crew_optimization": {
      "total_crew": 99,
      "operational_crew": 36,
      "diplomatic_passengers": 63,
      "breakdown": {
        "command": 1,
        "engineering": 14,
        "medical": 8,
        "science": 7,
        "maintenance": 4,
        "security": 1,
        "support": 1,
        "ambassadors": 4,
        "senior_diplomats": 8,
        "diplomatic_staff": 26,
        "security_detail": 8,
        "technical_advisors": 10,
        "cultural_attaches": 4
      }
    },
    "economic_performance": {
      "roi": "249.05%",
      "net_profit": "$512.59M",
      "mission_type": "diplomatic"
    }
  },
  "ship_specifications": {
    "length": 300.0,
    "beam": 50.0,
    "height": 40.0,
    "total_decks": 13,
    "deck_spacing": 3.3333333333333335
  },
  "deck_plans": [
    {
      "name": "Deck_13",
      "level": 20.0,
      "function": "Command & VIP Lounge",
      "total_occupancy": 1,
      "boundary": [[105.0, 0.0], [102.98, 4.88], [97.01, 9.57], [87.30, 13.89], [74.25, 17.68], [58.33, 20.79], [40.18, 23.10], [20.48, 24.52], [0.0, 25.0], [-20.48, 24.52], [-40.18, 23.10], [-58.33, 20.79], [-74.25, 17.68], [-87.30, 13.89], [-97.01, 9.57], [-102.98, 4.88], [-105.0, 0.0], [-102.98, -4.88], [-97.01, -9.57], [-87.30, -13.89], [-74.25, -17.68], [-58.33, -20.79], [-40.18, -23.10], [-20.48, -24.52], [0.0, -25.0], [20.48, -24.52], [40.18, -23.10], [58.33, -20.79], [74.25, -17.68], [87.30, -13.89], [97.01, -9.57], [102.98, -4.88]],
      "rooms": [
        {
          "id": "bridge",
          "type": "bridge",
          "name": "Main Bridge",
          "center": [0, 0],
          "area": 150.0,
          "boundary": [[-9.49, -7.75], [9.49, -7.75], [9.49, 7.75], [-9.49, 7.75]],
          "occupancy": 12,
          "privacy_level": "high",
          "amenities": ["command_stations", "navigation", "communications", "tactical"]
        },
        {
          "id": "captain_ready",
          "type": "office",
          "name": "Captain's Ready Room",
          "center": [-30, 0],
          "area": 30.0,
          "boundary": [[-4.24, -3.54], [4.24, -3.54], [4.24, 3.54], [-4.24, 3.54]],
          "occupancy": 1,
          "privacy_level": "vip",
          "amenities": ["private_office", "secure_comm", "meeting_space"]
        },
        {
          "id": "vip_lounge",
          "type": "lounge",
          "name": "VIP Diplomatic Lounge",
          "center": [50, 0],
          "area": 100.0,
          "boundary": [[-7.75, -6.45], [7.75, -6.45], [7.75, 6.45], [-7.75, 6.45]],
          "occupancy": 20,
          "privacy_level": "vip",
          "amenities": ["luxury_seating", "observation_windows", "refreshments"]
        }
      ],
      "corridors": []
    },
    {
      "name": "Deck_12",
      "level": 16.7,
      "function": "VIP Diplomatic Quarters",
      "total_occupancy": 12,
      "boundary": [[105.0, 0.0], [102.98, 4.88], [97.01, 9.57], [87.30, 13.89], [74.25, 17.68], [58.33, 20.79], [40.18, 23.10], [20.48, 24.52], [0.0, 25.0], [-20.48, 24.52], [-40.18, 23.10], [-58.33, 20.79], [-74.25, 17.68], [-87.30, 13.89], [-97.01, 9.57], [-102.98, 4.88], [-105.0, 0.0], [-102.98, -4.88], [-97.01, -9.57], [-87.30, -13.89], [-74.25, -17.68], [-58.33, -20.79], [-40.18, -23.10], [-20.48, -24.52], [0.0, -25.0], [20.48, -24.52], [40.18, -23.10], [58.33, -20.79], [74.25, -17.68], [87.30, -13.89], [97.01, -9.57], [102.98, -4.88]],
      "rooms": [
        {
          "id": "amb_suite_01",
          "type": "vip_quarters",
          "name": "Ambassador Suite 1",
          "center": [-60, 15],
          "area": 50.0,
          "boundary": [[-5.48, -4.56], [5.48, -4.56], [5.48, 4.56], [-5.48, 4.56]],
          "occupancy": 1,
          "privacy_level": "vip",
          "amenities": ["private_bathroom", "office_space", "secure_comm", "luxury_furnishing"]
        },
        {
          "id": "amb_suite_02",
          "type": "vip_quarters",
          "name": "Ambassador Suite 2",
          "center": [-20, -15],
          "area": 50.0,
          "boundary": [[-5.48, -4.56], [5.48, -4.56], [5.48, 4.56], [-5.48, 4.56]],
          "occupancy": 1,
          "privacy_level": "vip",
          "amenities": ["private_bathroom", "office_space", "secure_comm", "luxury_furnishing"]
        },
        {
          "id": "amb_suite_03",
          "type": "vip_quarters",
          "name": "Ambassador Suite 3",
          "center": [20, 15],
          "area": 50.0,
          "boundary": [[-5.48, -4.56], [5.48, -4.56], [5.48, 4.56], [-5.48, 4.56]],
          "occupancy": 1,
          "privacy_level": "vip",
          "amenities": ["private_bathroom", "office_space", "secure_comm", "luxury_furnishing"]
        },
        {
          "id": "amb_suite_04",
          "type": "vip_quarters",
          "name": "Ambassador Suite 4",
          "center": [60, -15],
          "area": 50.0,
          "boundary": [[-5.48, -4.56], [5.48, -4.56], [5.48, 4.56], [-5.48, 4.56]],
          "occupancy": 1,
          "privacy_level": "vip",
          "amenities": ["private_bathroom", "office_space", "secure_comm", "luxury_furnishing"]
        },
        {
          "id": "vip_dining",
          "type": "dining",
          "name": "VIP Diplomatic Dining",
          "center": [0, 0],
          "area": 100.0,
          "boundary": [[-7.75, -6.45], [7.75, -6.45], [7.75, 6.45], [-7.75, 6.45]],
          "occupancy": 20,
          "privacy_level": "standard",
          "amenities": ["formal_dining", "cultural_kitchen", "wine_storage"]
        }
      ],
      "corridors": []
    },
    {
      "name": "Deck_11",
      "level": 13.3,
      "function": "Diplomatic Staff Quarters",
      "total_occupancy": 13,
      "boundary": [[105.0, 0.0], [102.98, 4.88], [97.01, 9.57], [87.30, 13.89], [74.25, 17.68], [58.33, 20.79], [40.18, 23.10], [20.48, 24.52], [0.0, 25.0], [-20.48, 24.52], [-40.18, 23.10], [-58.33, 20.79], [-74.25, 17.68], [-87.30, 13.89], [-97.01, 9.57], [-102.98, 4.88], [-105.0, 0.0], [-102.98, -4.88], [-97.01, -9.57], [-87.30, -13.89], [-74.25, -17.68], [-58.33, -20.79], [-40.18, -23.10], [-20.48, -24.52], [0.0, -25.0], [20.48, -24.52], [40.18, -23.10], [58.33, -20.79], [74.25, -17.68], [87.30, -13.89], [97.01, -9.57], [102.98, -4.88]],
      "rooms": [
        {
          "id": "dipl_staff_01",
          "type": "diplomatic_quarters",
          "name": "Diplomatic Staff 1",
          "center": [-75, -10],
          "area": 20.0,
          "boundary": [[-3.46, -2.89], [3.46, -2.89], [3.46, 2.89], [-3.46, 2.89]],
          "occupancy": 1,
          "privacy_level": "high",
          "amenities": ["private_bathroom", "workspace", "secure_comm"]
        },
        {
          "id": "conference_center",
          "type": "conference",
          "name": "Diplomatic Conference Center",
          "center": [80, 15],
          "area": 120.0,
          "boundary": [[-8.49, -7.07], [8.49, -7.07], [8.49, 7.07], [-8.49, 7.07]],
          "occupancy": 50,
          "privacy_level": "high",
          "amenities": ["presentation_equipment", "translation_services", "recording"]
        }
      ],
      "corridors": []
    },
    {
      "name": "Deck_10",
      "level": 10.0,
      "function": "Diplomatic Staff Quarters",
      "total_occupancy": 13,
      "boundary": [[105.0, 0.0], [102.98, 4.88], [97.01, 9.57], [87.30, 13.89], [74.25, 17.68], [58.33, 20.79], [40.18, 23.10], [20.48, 24.52], [0.0, 25.0], [-20.48, 24.52], [-40.18, 23.10], [-58.33, 20.79], [-74.25, 17.68], [-87.30, 13.89], [-97.01, 9.57], [-102.98, 4.88], [-105.0, 0.0], [-102.98, -4.88], [-97.01, -9.57], [-87.30, -13.89], [-74.25, -17.68], [-58.33, -20.79], [-40.18, -23.10], [-20.48, -24.52], [0.0, -25.0], [20.48, -24.52], [40.18, -23.10], [58.33, -20.79], [74.25, -17.68], [87.30, -13.89], [97.01, -9.57], [102.98, -4.88]],
      "rooms": [
        {
          "id": "staff_lounge",
          "type": "lounge",
          "name": "Diplomatic Staff Lounge",
          "center": [50, 0],
          "area": 80.0,
          "boundary": [[-6.93, -5.77], [6.93, -5.77], [6.93, 5.77], [-6.93, 5.77]],
          "occupancy": 25,
          "privacy_level": "standard",
          "amenities": ["meeting_space", "recreation", "refreshments"]
        }
      ],
      "corridors": []
    },
    {
      "name": "Deck_9",
      "level": 6.7,
      "function": "Crew Quarters",
      "total_occupancy": 18,
      "boundary": [[105.0, 0.0], [102.98, 4.88], [97.01, 9.57], [87.30, 13.89], [74.25, 17.68], [58.33, 20.79], [40.18, 23.10], [20.48, 24.52], [0.0, 25.0], [-20.48, 24.52], [-40.18, 23.10], [-58.33, 20.79], [-74.25, 17.68], [-87.30, 13.89], [-97.01, 9.57], [-102.98, 4.88], [-105.0, 0.0], [-102.98, -4.88], [-97.01, -9.57], [-87.30, -13.89], [-74.25, -17.68], [-58.33, -20.79], [-40.18, -23.10], [-20.48, -24.52], [0.0, -25.0], [20.48, -24.52], [40.18, -23.10], [58.33, -20.79], [74.25, -17.68], [87.30, -13.89], [97.01, -9.57], [102.98, -4.88]],
      "rooms": [
        {
          "id": "security_01",
          "type": "crew_quarters",
          "name": "Security 1",
          "center": [-87.5, -15],
          "area": 15.0,
          "boundary": [[-3.0, -2.5], [3.0, -2.5], [3.0, 2.5], [-3.0, 2.5]],
          "occupancy": 1,
          "privacy_level": "standard",
          "amenities": ["private_bathroom", "storage", "personal_workspace"]
        },
        {
          "id": "crew_common",
          "type": "common",
          "name": "Crew Common Room",
          "center": [70, 0],
          "area": 60.0,
          "boundary": [[-6.0, -5.0], [6.0, -5.0], [6.0, 5.0], [-6.0, 5.0]],
          "occupancy": 20,
          "privacy_level": "standard",
          "amenities": ["recreation", "dining", "meeting_space"]
        }
      ],
      "corridors": []
    },
    {
      "name": "Deck_8",
      "level": 3.3,
      "function": "Support Staff & Recreation",
      "total_occupancy": 4,
      "boundary": [[105.0, 0.0], [102.98, 4.88], [97.01, 9.57], [87.30, 13.89], [74.25, 17.68], [58.33, 20.79], [40.18, 23.10], [20.48, 24.52], [0.0, 25.0], [-20.48, 24.52], [-40.18, 23.10], [-58.33, 20.79], [-74.25, 17.68], [-87.30, 13.89], [-97.01, 9.57], [-102.98, 4.88], [-105.0, 0.0], [-102.98, -4.88], [-97.01, -9.57], [-87.30, -13.89], [-74.25, -17.68], [-58.33, -20.79], [-40.18, -23.10], [-20.48, -24.52], [0.0, -25.0], [20.48, -24.52], [40.18, -23.10], [58.33, -20.79], [74.25, -17.68], [87.30, -13.89], [97.01, -9.57], [102.98, -4.88]],
      "rooms": [
        {
          "id": "cultural_01",
          "type": "diplomatic_quarters",
          "name": "Cultural Attaché 1",
          "center": [-80, 15],
          "area": 15.0,
          "boundary": [[-3.0, -2.5], [3.0, -2.5], [3.0, 2.5], [-3.0, 2.5]],
          "occupancy": 1,
          "privacy_level": "standard",
          "amenities": ["private_bathroom", "cultural_workspace"]
        },
        {
          "id": "recreation_center",
          "type": "recreation",
          "name": "Main Recreation Center",
          "center": [0, 0],
          "area": 200.0,
          "boundary": [[-10.95, -9.13], [10.95, -9.13], [10.95, 9.13], [-10.95, 9.13]],
          "occupancy": 50,
          "privacy_level": "standard",
          "amenities": ["entertainment", "games", "social_space", "cultural_programs"]
        }
      ],
      "corridors": []
    },
    {
      "name": "Deck_7",
      "level": 0.0,
      "function": "Main Operations & Senior Crew",
      "total_occupancy": 3,
      "boundary": [[105.0, 0.0], [102.98, 4.88], [97.01, 9.57], [87.30, 13.89], [74.25, 17.68], [58.33, 20.79], [40.18, 23.10], [20.48, 24.52], [0.0, 25.0], [-20.48, 24.52], [-40.18, 23.10], [-58.33, 20.79], [-74.25, 17.68], [-87.30, 13.89], [-97.01, 9.57], [-102.98, 4.88], [-105.0, 0.0], [-102.98, -4.88], [-97.01, -9.57], [-87.30, -13.89], [-74.25, -17.68], [-58.33, -20.79], [-40.18, -23.10], [-20.48, -24.52], [0.0, -25.0], [20.48, -24.52], [40.18, -23.10], [58.33, -20.79], [74.25, -17.68], [87.30, -13.89], [97.01, -9.57], [102.98, -4.88]],
      "rooms": [
        {
          "id": "captain_quarters",
          "type": "senior_quarters",
          "name": "Captain Quarters",
          "center": [-60, 15],
          "area": 25.0,
          "boundary": [[-3.87, -3.23], [3.87, -3.23], [3.87, 3.23], [-3.87, 3.23]],
          "occupancy": 1,
          "privacy_level": "high",
          "amenities": ["private_bathroom", "office_space", "luxury_amenities"]
        },
        {
          "id": "operations_center",
          "type": "operations",
          "name": "Mission Operations Center",
          "center": [0, 0],
          "area": 120.0,
          "boundary": [[-8.49, -7.07], [8.49, -7.07], [8.49, 7.07], [-8.49, 7.07]],
          "occupancy": 15,
          "privacy_level": "standard",
          "amenities": ["mission_control", "communications", "monitoring", "coordination"]
        },
        {
          "id": "medical_bay",
          "type": "medical",
          "name": "Comprehensive Medical Bay",
          "center": [70, 0],
          "area": 180.0,
          "boundary": [[-10.39, -8.66], [10.39, -8.66], [10.39, 8.66], [-10.39, 8.66]],
          "occupancy": 20,
          "privacy_level": "high",
          "amenities": ["surgery_suite", "diagnostic_equipment", "patient_care", "pharmacy"]
        }
      ],
      "corridors": []
    }
  ],
  "validation": {
    "total_planned_occupancy": 99,
    "target_crew": 99,
    "occupancy_match": true
  }
};
            console.log('Loaded embedded deck plans:', deckPlansData);
            setupDeckButtons();
            render();
        }

        function setupDeckButtons() {
            const container = document.getElementById('deck-buttons');
            container.innerHTML = '';
            
            // Add hull-only button
            const hullButton = document.createElement('button');
            hullButton.className = 'deck-button active';
            hullButton.textContent = 'Hull Only';
            hullButton.onclick = () => showDeck(-1);
            container.appendChild(hullButton);
            
            // Add deck buttons
            if (deckPlansData && deckPlansData.deck_plans) {
                deckPlansData.deck_plans.forEach((deck, index) => {
                    const button = document.createElement('button');
                    button.className = 'deck-button';
                    button.textContent = `${deck.name}: ${deck.function} (${deck.total_occupancy} crew)`;
                    button.onclick = () => showDeck(index);
                    container.appendChild(button);
                });
            }
        }

        function showDeck(deckIndex) {
            currentDeck = deckIndex;
            
            // Update button states
            const buttons = document.querySelectorAll('.deck-button');
            buttons.forEach((btn, i) => {
                btn.classList.toggle('active', i === deckIndex + 1);
            });
            
            // Update info panel
            if (deckIndex === -1) {
                document.getElementById('deck-name').textContent = 'Hull Only';
                document.getElementById('deck-level').textContent = '-';
                document.getElementById('deck-function').textContent = '-';
                document.getElementById('deck-occupancy').textContent = '-';
                document.getElementById('deck-rooms').textContent = '-';
            } else if (deckPlansData && deckPlansData.deck_plans[deckIndex]) {
                const deck = deckPlansData.deck_plans[deckIndex];
                document.getElementById('deck-name').textContent = deck.name;
                document.getElementById('deck-level').textContent = deck.level.toFixed(1) + 'm';
                document.getElementById('deck-function').textContent = deck.function;
                document.getElementById('deck-occupancy').textContent = deck.total_occupancy + ' people';
                document.getElementById('deck-rooms').textContent = deck.rooms ? deck.rooms.length : 0;
            }
            
            render();
        }

        function setViewMode(mode) {
            viewMode = mode;
            
            // Update button states
            document.querySelectorAll('[id^="view-"]').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`view-${mode}`).classList.add('active');
            
            render();
        }

        function updateZoom(value) {
            zoomLevel = parseFloat(value);
            document.getElementById('zoom_value').textContent = zoomLevel.toFixed(1) + 'x';
            render();
        }

        function updateRotation(value) {
            rotationAngle = parseFloat(value) * Math.PI / 180;
            document.getElementById('rotation_value').textContent = value + '°';
            render();
        }

        function toggleRooms() {
            showRooms = !showRooms;
            document.getElementById('show-rooms').classList.toggle('active', showRooms);
            render();
        }

        function toggleLabels() {
            showLabels = !showLabels;
            document.getElementById('show-labels').classList.toggle('active', showLabels);
            render();
        }

        function toggleHull() {
            showHull = !showHull;
            document.getElementById('show-hull').classList.toggle('active', showHull);
            render();
        }

        function toggleRoomType(type) {
            roomFilters[type] = !roomFilters[type];
            document.getElementById(`filter-${type}`).classList.toggle('active', roomFilters[type]);
            render();
        }

        function getRoomTypeCategory(roomType) {
            if (roomType.includes('diplomatic') || roomType.includes('vip') || roomType.includes('ambassador')) {
                return 'diplomatic';
            } else if (roomType.includes('crew') || roomType.includes('quarters') || roomType.includes('senior')) {
                return 'crew';
            } else if (roomType.includes('engine') || roomType.includes('control') || roomType.includes('processing') || roomType.includes('workshop')) {
                return 'systems';
            } else {
                return 'common';
            }
        }

        function render() {
            if (!gl || !program) return;
            
            // Clear canvas
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.02, 0.02, 0.05, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.useProgram(program);
            
            // Set uniforms
            gl.uniform2f(program.resolutionUniformLocation, canvas.width, canvas.height);
            gl.uniform2f(program.translationUniformLocation, cameraX + canvas.width/2, cameraY + canvas.height/2);
            gl.uniform1f(program.rotationUniformLocation, rotationAngle);
            gl.uniform1f(program.scaleUniformLocation, zoomLevel);
            
            // Enable blending for transparency
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            // Draw starship hull if enabled
            if (showHull) {
                drawStarshipHull();
            }
            
            // Draw deck plan if selected
            if (currentDeck !== -1 && showRooms) {
                drawDetailedDeckPlan();
            }
        }

        function drawStarshipHull() {
            const vertices = [];
            const colors = [];
            
            if (viewMode === 'top') {
                // Top-down view: Show full starship outline
                drawStarshipTopView(vertices, colors);
            } else if (viewMode === 'side') {
                // Side view: Show starship profile
                drawStarshipSideView(vertices, colors);
            } else {
                // 3D view: Show isometric starship
                drawStarship3DView(vertices, colors);
            }
            
            if (vertices.length > 0) {
                drawLines(vertices, colors);
            }
        }

        function drawStarshipTopView(vertices, colors) {
            // Create realistic FTL starship outline from top
            const shipLength = 300;
            const shipBeam = 50;
            const scale = 1.2;
            
            // Main hull outline (elongated diamond shape)
            const hullPoints = [
                [-shipLength/2 * scale, 0],                    // Nose
                [-shipLength/3 * scale, shipBeam/4 * scale],   // Forward port
                [-shipLength/4 * scale, shipBeam/2 * scale],   // Mid-forward port
                [0, shipBeam/2 * scale],                       // Amidships port
                [shipLength/4 * scale, shipBeam/3 * scale],    // Aft port
                [shipLength/2 * scale, 0],                     // Stern
                [shipLength/4 * scale, -shipBeam/3 * scale],   // Aft starboard
                [0, -shipBeam/2 * scale],                      // Amidships starboard
                [-shipLength/4 * scale, -shipBeam/2 * scale],  // Mid-forward starboard
                [-shipLength/3 * scale, -shipBeam/4 * scale],  // Forward starboard
            ];
            
            // Draw main hull outline
            for (let i = 0; i < hullPoints.length; i++) {
                const current = hullPoints[i];
                const next = hullPoints[(i + 1) % hullPoints.length];
                
                vertices.push(current[0], current[1], next[0], next[1]);
                colors.push(0.3, 0.9, 0.9, 0.8);  // Cyan hull outline
                colors.push(0.3, 0.9, 0.9, 0.8);
            }
            
            // Add warp nacelles
            const nacelleLength = shipLength * 0.4;
            const nacelleOffset = shipBeam * 0.7;
            
            // Port nacelle
            vertices.push(-nacelleLength/2, nacelleOffset, nacelleLength/2, nacelleOffset);
            colors.push(1.0, 0.3, 0.3, 0.9);  // Red nacelles
            colors.push(1.0, 0.3, 0.3, 0.9);
            
            // Starboard nacelle  
            vertices.push(-nacelleLength/2, -nacelleOffset, nacelleLength/2, -nacelleOffset);
            colors.push(1.0, 0.3, 0.3, 0.9);
            colors.push(1.0, 0.3, 0.3, 0.9);
            
            // Nacelle struts
            vertices.push(-shipLength/6, shipBeam/3 * scale, -nacelleLength/3, nacelleOffset);
            colors.push(0.6, 0.6, 0.6, 0.7);  // Gray struts
            colors.push(0.6, 0.6, 0.6, 0.7);
            
            vertices.push(-shipLength/6, -shipBeam/3 * scale, -nacelleLength/3, -nacelleOffset);
            colors.push(0.6, 0.6, 0.6, 0.7);
            colors.push(0.6, 0.6, 0.6, 0.7);
            
            // Bridge superstructure
            const bridgeSize = 15;
            vertices.push(-shipLength/3, -bridgeSize/2, -shipLength/3, bridgeSize/2);
            vertices.push(-shipLength/3, bridgeSize/2, -shipLength/3 + bridgeSize, bridgeSize/2);
            vertices.push(-shipLength/3 + bridgeSize, bridgeSize/2, -shipLength/3 + bridgeSize, -bridgeSize/2);
            vertices.push(-shipLength/3 + bridgeSize, -bridgeSize/2, -shipLength/3, -bridgeSize/2);
            
            for (let i = 0; i < 8; i++) {
                colors.push(1.0, 1.0, 0.3, 0.9);  // Yellow bridge
            }
        }

        function drawStarshipSideView(vertices, colors) {
            // Create realistic FTL starship profile from side
            const shipLength = 300;
            const shipHeight = 40;
            const scale = 1.2;
            
            // Main hull profile (streamlined shape)
            const hullPoints = [
                [-shipLength/2 * scale, 0],                      // Nose bottom
                [-shipLength/2 * scale + 20, shipHeight/3 * scale], // Nose top
                [-shipLength/3 * scale, shipHeight/2 * scale],    // Forward deck
                [0, shipHeight/2 * scale],                        // Amidships top
                [shipLength/3 * scale, shipHeight/3 * scale],     // Aft deck
                [shipLength/2 * scale, 0],                        // Stern
                [shipLength/3 * scale, -shipHeight/4 * scale],    // Aft bottom
                [0, -shipHeight/3 * scale],                       // Amidships bottom
                [-shipLength/4 * scale, -shipHeight/3 * scale],   // Forward bottom
            ];
            
            // Draw main hull profile
            for (let i = 0; i < hullPoints.length; i++) {
                const current = hullPoints[i];
                const next = hullPoints[(i + 1) % hullPoints.length];
                
                vertices.push(current[0], current[1], next[0], next[1]);
                colors.push(0.3, 0.9, 0.9, 0.8);  // Cyan hull outline
                colors.push(0.3, 0.9, 0.9, 0.8);
            }
            
            // Add deck lines
            for (let deck = 1; deck <= 13; deck++) {
                const deckY = -shipHeight/2 + (deck - 1) * shipHeight/12;
                const deckLength = shipLength * (0.8 - Math.abs(deck - 7) * 0.05);
                
                vertices.push(-deckLength/2, deckY * scale, deckLength/2, deckY * scale);
                colors.push(0.5, 0.5, 0.9, 0.4);  // Blue deck lines
                colors.push(0.5, 0.5, 0.9, 0.4);
            }
            
            // Bridge superstructure
            vertices.push(-shipLength/3, shipHeight/2 * scale, -shipLength/3 + 30, shipHeight/2 * scale + 15);
            vertices.push(-shipLength/3 + 30, shipHeight/2 * scale + 15, -shipLength/3 + 30, shipHeight/2 * scale);
            vertices.push(-shipLength/3 + 30, shipHeight/2 * scale, -shipLength/3, shipHeight/2 * scale);
            
            for (let i = 0; i < 6; i++) {
                colors.push(1.0, 1.0, 0.3, 0.9);  // Yellow bridge
            }
            
            // Warp nacelles (side view)
            const nacelleY = -shipHeight/2 * scale;
            vertices.push(-shipLength/3, nacelleY, shipLength/3, nacelleY);
            colors.push(1.0, 0.3, 0.3, 0.9);  // Red nacelles
            colors.push(1.0, 0.3, 0.3, 0.9);
        }

        function drawStarship3DView(vertices, colors) {
            // Create isometric 3D view of starship
            const shipLength = 300;
            const shipBeam = 50;
            const shipHeight = 40;
            const scale = 1.0;
            
            // Isometric projection factors
            const isoX = 0.866;  // cos(30°)
            const isoY = 0.5;    // sin(30°)
            
            function project3D(x, y, z) {
                return [
                    (x - z) * isoX * scale,
                    (y + z * isoY) * scale
                ];
            }
            
            // Draw main hull in 3D
            const hullCorners = [
                // Bottom face
                [-shipLength/2, -shipHeight/2, -shipBeam/2],
                [shipLength/2, -shipHeight/2, -shipBeam/2],
                [shipLength/2, -shipHeight/2, shipBeam/2],
                [-shipLength/2, -shipHeight/2, shipBeam/2],
                // Top face
                [-shipLength/2, shipHeight/2, -shipBeam/2],
                [shipLength/2, shipHeight/2, -shipBeam/2],
                [shipLength/2, shipHeight/2, shipBeam/2],
                [-shipLength/2, shipHeight/2, shipBeam/2],
            ];
            
            const projectedCorners = hullCorners.map(corner => project3D(corner[0], corner[1], corner[2]));
            
            // Draw hull edges
            const edges = [
                [0,1], [1,2], [2,3], [3,0],  // Bottom face
                [4,5], [5,6], [6,7], [7,4],  // Top face
                [0,4], [1,5], [2,6], [3,7]   // Vertical edges
            ];
            
            edges.forEach(edge => {
                const start = projectedCorners[edge[0]];
                const end = projectedCorners[edge[1]];
                
                vertices.push(start[0], start[1], end[0], end[1]);
                colors.push(0.3, 0.9, 0.9, 0.8);  // Cyan hull
                colors.push(0.3, 0.9, 0.9, 0.8);
            });
            
            // Add 3D nacelles
            const nacelles = [
                // Port nacelle
                [[-shipLength/3, -shipHeight/2, shipBeam], [shipLength/3, -shipHeight/2, shipBeam]],
                // Starboard nacelle
                [[-shipLength/3, -shipHeight/2, -shipBeam], [shipLength/3, -shipHeight/2, -shipBeam]]
            ];
            
            nacelles.forEach(nacelle => {
                const start = project3D(nacelle[0][0], nacelle[0][1], nacelle[0][2]);
                const end = project3D(nacelle[1][0], nacelle[1][1], nacelle[1][2]);
                
                vertices.push(start[0], start[1], end[0], end[1]);
                colors.push(1.0, 0.3, 0.3, 0.9);  // Red nacelles
                colors.push(1.0, 0.3, 0.3, 0.9);
            });
        }

        function drawDetailedDeckPlan() {
            if (!deckPlansData || currentDeck === -1 || !deckPlansData.deck_plans[currentDeck]) return;
            
            const deck = deckPlansData.deck_plans[currentDeck];
            if (!deck.rooms) return;
            
            const vertices = [];
            const colors = [];
            
            // Draw deck boundary first
            drawDeckBoundary(deck, vertices, colors);
            
            // Draw detailed rooms
            deck.rooms.forEach(room => {
                const category = getRoomTypeCategory(room.type);
                if (!roomFilters[category]) return;
                
                drawDetailedRoom(room, vertices, colors);
            });
            
            if (vertices.length > 0) {
                drawGeometry(vertices, colors);
            }
        }

        function drawDeckBoundary(deck, vertices, colors) {
            if (!deck.boundary) return;
            
            const scale = viewMode === 'top' ? 2 : 1.5;
            const boundary = deck.boundary;
            
            // Create deck outline with proper starship shape
            for (let i = 0; i < boundary.length; i++) {
                const current = boundary[i];
                const next = boundary[(i + 1) % boundary.length];
                
                vertices.push(
                    current[0] * scale, viewMode === 'top' ? current[1] * scale : 0,
                    next[0] * scale, viewMode === 'top' ? next[1] * scale : 0
                );
                
                // Deck outline color
                colors.push(0.4, 0.8, 1.0, 0.6);
                colors.push(0.4, 0.8, 1.0, 0.6);
            }
        }

        function drawDetailedRoom(room, vertices, colors) {
            const scale = viewMode === 'top' ? 2 : 1.5;
            const centerX = room.center[0] * scale;
            const centerY = viewMode === 'top' ? room.center[1] * scale : 0;
            
            // Get room color
            const roomColor = roomColors[room.type] || [0.5, 0.5, 0.5, 0.8];
            
            // Create detailed room shape based on type
            let roomVertices = [];
            
            if (room.type === 'bridge') {
                // Bridge - hexagonal shape
                roomVertices = createHexagonRoom(centerX, centerY, Math.sqrt(room.area), scale);
            } else if (room.type.includes('quarters')) {
                // Quarters - rectangular with rounded corners
                roomVertices = createQuartersRoom(centerX, centerY, room.area, scale);
            } else if (room.type === 'dining' || room.type === 'lounge') {
                // Dining/Lounge - oval shape
                roomVertices = createOvalRoom(centerX, centerY, room.area, scale);
            } else if (room.type === 'medical') {
                // Medical - cross shape
                roomVertices = createCrossRoom(centerX, centerY, room.area, scale);
            } else {
                // Default - rectangle
                roomVertices = createRectangleRoom(centerX, centerY, room.area, scale);
            }
            
            // Create triangles for room fill
            for (let i = 1; i < roomVertices.length - 1; i++) {
                vertices.push(
                    roomVertices[0][0], roomVertices[0][1],
                    roomVertices[i][0], roomVertices[i][1],
                    roomVertices[i + 1][0], roomVertices[i + 1][1]
                );
                
                // Add colors for triangle
                for (let j = 0; j < 3; j++) {
                    colors.push(...roomColor);
                }
            }
            
            // Draw room outline
            for (let i = 0; i < roomVertices.length; i++) {
                const current = roomVertices[i];
                const next = roomVertices[(i + 1) % roomVertices.length];
                
                vertices.push(current[0], current[1], next[0], next[1]);
                colors.push(1.0, 1.0, 1.0, 0.9);  // White outline
                colors.push(1.0, 1.0, 1.0, 0.9);
            }
            
            // Add room label if enabled
            if (showLabels) {
                // Add center point for label
                vertices.push(centerX-1, centerY, centerX+1, centerY);
                colors.push(1.0, 1.0, 1.0, 1.0);
                colors.push(1.0, 1.0, 1.0, 1.0);
            }
        }

        function createHexagonRoom(x, y, size, scale) {
            const vertices = [];
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI) / 3;
                vertices.push([
                    x + Math.cos(angle) * size,
                    y + Math.sin(angle) * size
                ]);
            }
            return vertices;
        }

        function createQuartersRoom(x, y, area, scale) {
            const width = Math.sqrt(area * 1.4);
            const height = area / width;
            const cornerRadius = Math.min(width, height) * 0.1;
            
            return [
                [x - width/2 + cornerRadius, y - height/2],
                [x + width/2 - cornerRadius, y - height/2],
                [x + width/2, y - height/2 + cornerRadius],
                [x + width/2, y + height/2 - cornerRadius],
                [x + width/2 - cornerRadius, y + height/2],
                [x - width/2 + cornerRadius, y + height/2],
                [x - width/2, y + height/2 - cornerRadius],
                [x - width/2, y - height/2 + cornerRadius]
            ];
        }

        function createOvalRoom(x, y, area, scale) {
            const vertices = [];
            const radiusX = Math.sqrt(area / Math.PI) * 1.2;
            const radiusY = Math.sqrt(area / Math.PI) * 0.8;
            
            for (let i = 0; i < 16; i++) {
                const angle = (i * 2 * Math.PI) / 16;
                vertices.push([
                    x + Math.cos(angle) * radiusX,
                    y + Math.sin(angle) * radiusY
                ]);
            }
            return vertices;
        }

        function createCrossRoom(x, y, area, scale) {
            const armWidth = Math.sqrt(area) * 0.3;
            const armLength = Math.sqrt(area) * 0.7;
            
            return [
                [x - armWidth/2, y - armLength],
                [x + armWidth/2, y - armLength],
                [x + armWidth/2, y - armWidth/2],
                [x + armLength, y - armWidth/2],
                [x + armLength, y + armWidth/2],
                [x + armWidth/2, y + armWidth/2],
                [x + armWidth/2, y + armLength],
                [x - armWidth/2, y + armLength],
                [x - armWidth/2, y + armWidth/2],
                [x - armLength, y + armWidth/2],
                [x - armLength, y - armWidth/2],
                [x - armWidth/2, y - armWidth/2]
            ];
        }

        function createRectangleRoom(x, y, area, scale) {
            const width = Math.sqrt(area * 1.5);
            const height = area / width;
            
            return [
                [x - width/2, y - height/2],
                [x + width/2, y - height/2],
                [x + width/2, y + height/2],
                [x - width/2, y + height/2]
            ];
        }

        function drawLines(vertices, colors) {
            const positionBuffer = gl.createBuffer();
            const colorBuffer = gl.createBuffer();
            
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            
            // Position attribute
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(program.positionAttributeLocation);
            gl.vertexAttribPointer(program.positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
            
            // Color attribute
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.enableVertexAttribArray(program.colorAttributeLocation);
            gl.vertexAttribPointer(program.colorAttributeLocation, 4, gl.FLOAT, false, 0, 0);
            
            gl.drawArrays(gl.LINES, 0, vertices.length / 2);
            
            gl.deleteBuffer(positionBuffer);
            gl.deleteBuffer(colorBuffer);
        }

        function drawGeometry(vertices, colors) {
            const positionBuffer = gl.createBuffer();
            const colorBuffer = gl.createBuffer();
            
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            
            // Position attribute
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(program.positionAttributeLocation);
            gl.vertexAttribPointer(program.positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
            
            // Color attribute
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.enableVertexAttribArray(program.colorAttributeLocation);
            gl.vertexAttribPointer(program.colorAttributeLocation, 4, gl.FLOAT, false, 0, 0);
            
            gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);
            
            gl.deleteBuffer(positionBuffer);
            gl.deleteBuffer(colorBuffer);
        }

        // Initialize everything
        window.addEventListener('load', () => {
            if (initWebGL()) {
                loadDeckPlans();
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render();
        });
    </script>
</body>
</html>
